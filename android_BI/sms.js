//smsMonitoring-smsFraud
var data = {
    sendCount: 0,
    msgFromPdu: 0,
    Pdu:[],
    destination: [],
    destInfo: [],
    source: [],
    content: [],
    pduUri: [],
    destUrl: []
};
var retunString = function(input){
    var str = input.replace('[','');
    var str1 = str.replace(']','');
    var res = str1.split(',');
    var ret = '';
    for(var i = 0; i<res.length; i++){
        if(res[i] > 31 && res[i]<127)
            ret += String.fromCharCode(res[i]);
        else ret += ' ';

    }
    return ret;
}
Java.perform(() => {
    var smsManager = Java.use('android.telephony.SmsManager');
    var smsMessage = Java.use('android.telephony.SmsMessage');

    smsMessage.createFromPdu.overloads[0].implementation = function(pdu){
        data.msgFromPdu++;
        var out = retunString(pdu);
        data.Pdu.push(out);
        return this.createFromPdu(pdu);
    }
    smsMessage.createFromPdu.overloads[1].implementation = function(pdu,format){
        data.msgFromPdu++;
        var out = retunString(pdu);
        data.Pdu.push(out);
        return this.createFromPdu(pdu,format);
    }
    smsManager.sendMultipartTextMessage.overloads[0].implementation = function(destinationAddress,  scAddress,  parts,  sentIntents,  deliveryIntents){
        data.sendCount++;
        data.destination.push(destinationAddress)
        data.source.push(scAddress)
        var iter = parts.iterator();
        while(iter.hasNext()) {
            data.content.push(iter.next());
        }
        checkDestination(destinationAddress);

        this.sendMultipartTextMessage(destinationAddress,  scAddress,  parts,  sentIntents,  deliveryIntents);
    }

    smsManager.sendMultipartTextMessage.overloads[1].implementation = function(destinationAddress,  scAddress,  parts,  sentIntents,  deliveryIntents,messageId){
        data.sendCount++;
        data.destination.push(destinationAddress)
        data.source.push(scAddress)
        var iter = parts.iterator();
        while(iter.hasNext()) {
            data.content.push(iter.next());
        }
        checkDestination(destinationAddress);
        this.sendMultipartTextMessage(destinationAddress,  scAddress,  parts,  sentIntents,  deliveryIntents);
    }
    smsManager.sendMultimediaMessage.implementation = function(context,uri,locationurl,configoverrides,pendingIntent){
        data.sendCount++;
        data.pduUri.push(uri)
        data.destUrl.push(locationurl);
        this.sendMultimediaMessage(context,uri,locationurl,configoverrides,pendingIntent);
    }
    smsManager.sendTextMessage.overloads[0].implementation = function(destinationAddress, scAddress, text,pendingIntent, deliveryIntent){
        data.sendCount++;
        data.destination.push(destinationAddress)
        data.source.push(scAddress)
        data.content.push(text);
        checkDestination(destinationAddress);
        this.sendTextMesssage(destinationAddress,scAddress,text,pendingIntent,deliveryIntent);
    }
    smsManager.sendTextMessage.overloads[1].implementation = function(destinationAddress, scAddress, text,pendingIntent, deliveryIntent,messageId){
        data.sendCount++;
        data.destination.push(destinationAddress)
        data.source.push(scAddress)
        data.content.push(text);
        checkDestination(destinationAddress);
        this.sendTextMesssage(destinationAddress,scAddress,text,pendingIntent,deliveryIntent,messageId);

    }
    function checkDestination(dest){
        var info = parseXml(dest);
        data.destInfo.push(info)
    }
    function parseXml(destinationAddress){
        const dest = Java.use('java.lang.String').$new(destinationAddress);
        var docBuilder = Java.use('javax.xml.parsers.DocumentBuilder');
        docBuilder = Java.use('javax.xml.parsers.DocumentBuilderFactory').newInstance().newDocumentBuilder();;
        // Avoids permission errors when trying to read from /data/misc/sms/codes
        var doc = docBuilder.parse('http://www.gstatic.com/android/config_update/02082024-sms-denylist.txt');
        var Pattern = Java.use('java.util.regex.Pattern');
        var nodeList = doc.getElementsByTagName('shortcode');
        var n = nodeList.getLength();
        var current, category, countryCode;

        for (var i = 0; i < n; i++) {
            current = nodeList.item(i);
            var country = current.getAttributes().getNamedItem('country')
            if (country != null) country = country.getNodeValue();

            var pattern = current.getAttributes().getNamedItem('pattern');
            if (pattern != null) pattern = pattern.getNodeValue();

            var premium = current.getAttributes().getNamedItem('premium');
            if (premium != null) premium = premium.getNodeValue();

            var standard = current.getAttributes().getNamedItem('standard');
            if (standard != null) standard = standard.getNodeValue();

            var free = current.getAttributes().getNamedItem('free');
            if (free != null) free = free.getNodeValue();

            var ShortCodePattern = (pattern != null ? Pattern.compile(pattern) : null);
            var PremiumShortCodePattern = (premium != null ?
                Pattern.compile(premium) : null);
            var FreeShortCodePattern = (free != null ?
                Pattern.compile(free) : null);
            var StandardShortCodePattern = (standard != null ?
                Pattern.compile(standard) : null);

            if (FreeShortCodePattern != null && FreeShortCodePattern.matcher(dest)
                .matches()) {
                if (category == null) 
                    category = 'Free';
            }
            if (StandardShortCodePattern != null && StandardShortCodePattern.matcher(dest)
                .matches()) {
                if (category != 'Possible Premium') {
                    category = 'Standard';
                    countryCode = country;
                }
            }
            if (PremiumShortCodePattern != null && PremiumShortCodePattern.matcher(dest)
                .matches()) {
                return ['Premium!', country]; 
                // If it's premium we can return early. Otherwise continue to 
                // search for the worst case scenario. This happens because the patterns are per country.
            }
            if (ShortCodePattern != null && ShortCodePattern.matcher(dest).matches()) {
                category = 'Possible Premium!';
                countryCode = country;
            }
        }
        var tmp = []
        category = category != null ? category : 'Not short code';
        tmp.push(category)
        countryCode = countryCode != null ? countryCode : '';
        tmp.push(countryCode)
        return tmp;
    }
});

function sendToPython(){
    send(data);
  }
setInterval(sendToPython, 5000);